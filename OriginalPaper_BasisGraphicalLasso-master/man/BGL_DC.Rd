% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BGL_DC.R
\name{BGL_DC}
\alias{BGL_DC}
\title{Basis Graphical Lasso Difference of Convex Algorithm}
\usage{
BGL_DC(
  lambda,
  Phi_Dinv_Phi,
  Phi_Dinv_S_Dinv_Phi,
  guess,
  outer_tol = NULL,
  MAX_ITER = NULL,
  MAX_RUNTIME_SECONDS = NULL,
  verbose = TRUE
)
}
\arguments{
\item{lambda}{Penalty be either a nonnegative real, or a matrix of nonnegative reals whose dimension is the same as the number of graph nodes.}

\item{Phi_Dinv_Phi}{Inner product of basis matrices, \eqn{\Phi'D^{-1}\Phi}. Typically obtained from using \code{BGLBasisSetup} with \eqn{D = \tau^2 I}.}

\item{Phi_Dinv_S_Dinv_Phi}{Inner product of the basis matrices and data, \eqn{\Phi'D^{-1}SD^{-1}\Phi}. Typically obtained from using \code{BGLBasisSetup} with \eqn{D = \tau^2 I}. This is where the data directly enters the algorithm. Note: do not compute sample covariance S explicitly. With \code{dat} as the n by m matrix with columns corresponding to realizations of the mean zero spatial field, we have \eqn{S=XX'/m}. So, setting D = I for simplicity, we can compute as \eqn{\Phi'S\Phi} as \code{tcrossprod(crossprod(Phi, dat))/m}.}

\item{guess}{Initial guess for the precision matrix.}

\item{outer_tol}{Tolerance. Default: NULL.}

\item{MAX_ITER}{Maximum number of iterations. Default: NULL.}

\item{MAX_RUNTIME_SECONDS}{Maximum runtime in seconds. Default: NULL.}

\item{verbose}{Print algorithm details after each iteration. Default: TRUE.}
}
\value{
Precision matrix of the random coefficients in the weighted sum of basis functions.
}
\description{
Estimates the precision matrix from the basis graphical lasso model.
}
\details{
This is the DC algorithm suggested in the paper and is the workhorse of the package. It uses the \code{QUIC} algorithm to solve the inner graphical lasso problem which arises after linearizing all concave functions w.r.t Q in the negative log likelihood. D is the covariance matrix of the additive error term epsilon in the model formulation; in the paper \eqn{D = \tau^2 I}. The package does not estimate non-identity multiple of D but we include the more general version for possible future research.
}
\examples{
basis.setup <- BGLBasisSetup(y=tmin$data,locs=tmin$lon.lat.proj,basis="LatticeKrig", 
     crossvalidation=FALSE,NC=20,nlevel=1)
Phi_Phi <- basis.setup$Phi_Phi
Phi_S_Phi <- basis.setup$Phi_S_Phi
tau_sq <- 2
lambda <- matrix(10,nrow=dim(Phi_Phi)[1],ncol=dim(Phi_Phi)[1])
diag(lambda) <- 0
BGLguess <- BGL_DC(lambda=lambda,Phi_Dinv_Phi=Phi_Phi/tau_sq,
     Phi_Dinv_S_Dinv_Phi=Phi_S_Phi/(tau_sq^2), guess=diag(dim(Phi_Phi)[1]),
     outer_tol=0.05,MAX_ITER=50,MAX_RUNTIME_SECONDS=86400)
}
